# Lab7实验报告
>* 熟悉ucore中的进程同步机制，了解操作系统为进程同步提供的底层支持；
>* 在ucore中理解信号量（semaphore）机制的具体实现；
>* 理解管程机制，在ucore内核中增加基于管程（monitor）的条件变量（condition variable）的支持；
>* 了解经典进程同步问题，并能使用同步机制解决进程同步问题。

标签（空格分隔）： ucore-lab

---

## 练习0：填写已有实验

本实验依赖实验1/2/3/4/5/6。请把你做的实验1/2/3/4/5/6的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab7的测试应用程序，可能需对已完成的实验1/2/3/4/5/6的代码进行进一步改进。
> 答：已经完成了前面代码的移植，并对需要修改的部分做了对应的修改

---

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）

完成练习0后，建议大家比较一下（可用kdiff3等文件比较软件）个人完成的lab6和练习0完成后的刚修改的lab7之间的区别，分析了解lab7采用信号量的执行过程。执行make grade，大部分测试用例应该通过。

请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。
请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
> 答：ucore中定义的最基本的记录型信号量semaphore_t中用于计数的整形型value和一个进程等待队列wait_queue，一个等待的进程会挂在此等待队列上；在ucore中最重要的信号量操作是：
(1).P操作：down(semaphore_t *sem) -> _down(semaphore_t *sem, unit32_t wait_state)
具体实现信号量的P操作，首先关掉中断，然后判断当前信号量的value是否大于0，如果大于0，则表明可获得信号量，value减一，并打开中断返回即可；如果value小于等于0，则表明无法获得信号量，故需要将当前的进程加入到等待队列，并打开中断，然后运行调度器选择另外一个进程执行；如果被V操作唤醒，则把自身关联的wait从等待队列中删除（需要先关中断，完成后开中断）。
(2).V操作：up(semaphore_t *sem) -> _up(semaphore_t *sem, unit32_t wait_state)
具体实现信号量的V操作，首先关中断，如果信号量对应的wait_queue中没有进程在等待，直接把信号量的value加1，然后开中断返回；如果有进程在等待且进程等待的原因是semaphore设置的，则调用wakeup_wait函数将wait_queue中等待的第一个wait删除，且把此wait关联的进程唤醒，最后开中断返回。

> 如果要给用户态进程提供信号量操作，因为down和up中都有调用调度器，必须要在内核态执行，所以可以新建系统调用如sys_down和sys_up用来申请资源和释放资源，在中断处理函数中调用内核态的函数即可。

--- 

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）

首先掌握管程机制，然后基于信号量实现完成条件变量实现，然后用管程机制实现哲学家就餐问题的解决方案（基于条件变量）。
执行：make grade 。如果所显示的应用程序检测都输出ok，则基本正确。如果只是某程序过不去，比如matrix.c，则可执行 make run-matrix 命令来单独调试它。大致执行结果可看附录。（使用的是qemu-1.0.1）。

请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程。
请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。
> 答：ucore中的管程机制是基于信号量和条件变量来实现的，管程的定义在monitor_t中，条件变量的定义中也包含了一系列的成员变量，信号量sem用于让发出wait_cv操作的等待某个条件C为真的进程睡眠，而让发出signal_cv操作的进程通过这个sem来唤醒睡眠的进程；count表示在这个条件变量上的睡眠进程的个数；owner表示此条件变量的宿主是哪个管程。ucore实现了条件变量wait_cv操作和signal_cv操作对应的具体函数：
(1). cond_wait：表示次进程等待某个条件C不为真，需要睡眠，因此表示此等待条件的睡眠进程个数要加1，同时根据monitor.next_count是否大于0分情况处理，如果大于0需要唤醒一个进程继续执行，否则需要唤醒由于互斥条件限制无法进入管程的进程。
(2). signal_wait：首先判断cv.count的值是否大于0，如果不大于0，则表示当前没有执行cond_wait而睡眠的进程，函数直接返回即可，大于0则需要唤醒睡眠的进程同时让自己睡眠，睡醒了让monitor.next_count减一即可。

> 哲学家就餐中如果左边和右边的哲学家都没有在吃饭就可以申请获得叉子，否则就需要等待，放下叉子时需要首先将自身设置为思考状态THINKING，然后尝试唤醒左边和右边的哲学家。
